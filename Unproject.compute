/*
 * Hardware Depth Unprojector (compute shader)
 * 
 * Copyright 2020 (C) Bartosz Meglicki <meglickib@gmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Compute shader for unprojecting depth map and color map to dense point cloud.
 * The result is stored in AppendStructureBuffer.
 *
 * This is Unity flavour HLSL. You may recompile it with Unity for OpenGL, Vulkan etc.
 */

#pragma kernel UnprojectKernel

#include "UnityCG.cginc"

CBUFFER_START(UnprojectionArgs)
    float3 UnprojectionMultiplier; //max distance * [1/fx, 1/fy, 1]
    float PPX; //principal point x pixel coordinates (center of projection)
    float PPY; //principal point y pixel coordinates (center of projection)
    float MinDistance; //in [0, 1], min valid distance divided by max distance, 0 accepts any
    float MaxDistance; //in [0, 1], max valid distance divided by max distance, 1 accepts any
CBUFFER_END

Texture2D<float> depthTexture; //sampled as red channel, in [0, 1] where 1 corresponds to max distance
Texture2D<float> colorTextureY; //Y plane of color corresponding to depth sample
Texture2D<float> colorTextureU; //U plane of color corresponding to depth sample (width/2, height/2)
Texture2D<float> colorTextureV; //V plane of color corresponding to depth sample (width/2, height/2)

struct VertexData
{
    float4 position;
    float4 color;
};

AppendStructuredBuffer<VertexData> vertices;

[numthreads(8,8,1)]
void UnprojectKernel (uint3 id : SV_DispatchThreadID)
{
    float d = depthTexture.Load(id.xyz);
    
    if(d < MinDistance || d > MaxDistance)
        return;

    float3 unprojection = {id.x - PPX, PPY - id.y, 1};
    float4 p = float4(d * unprojection * UnprojectionMultiplier, 1);
    
    float y = colorTextureY[id.xy];
    float u = colorTextureU[uint2(id.x / 2, id.y / 2)];
    float v = colorTextureV[uint2(id.x / 2, id.y / 2)];

    u = u - 0.5;
    v = v - 0.5;
    float r = (1.164f * y + 1.596f * v);
    float g = (1.164f * y - 0.813f * v - 0.391f * u);
    float b = (1.164f * y + 2.018f * u);

    VertexData vertex = {p, float4(r, g, b, 1)};
    vertices.Append(vertex);
}

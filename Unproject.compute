/*
 * Hardware Depth Unprojector (compute shader)
 * 
 * Copyright 2020 (C) Bartosz Meglicki <meglickib@gmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Compute shader for unprojecting depth map and color map to dense point cloud.
 * The result is stored in AppendStructureBuffer.
 *
 * This is Unity flavour HLSL. You may recompile it with Unity for OpenGL, Vulkan etc.
 */

#pragma kernel UnprojectKernel

#include "UnityCG.cginc"

CBUFFER_START(UnprojectionArgs)
    float3 UnprojectionMultiplier; //max distance * [1/fx, 1/fy, 1]
    float PPX; //principal point x pixel coordinates (center of projection)
    float PPY; //principal point y pixel coordinates (center of projection)
    float MinDistance; //in [0, 1], min valid distance divided by max distance, 0 accepts any
    float MaxDistance; //in [0, 1], max valid distance divided by max distance, 1 accepts any
CBUFFER_END

Texture2D<float> depthTexture; //sampled as red channel, in [0, 1] where 1 corresponds to max distance
Texture2D<float> colorTextureY; //Y plane of color corresponding to depth sample
Texture2D<float> colorTextureU; //U plane of color corresponding to depth sample (width/2, height/2)
Texture2D<float> colorTextureV; //V plane of color corresponding to depth sample (width/2, height/2)

struct VertexData
{
    float4 position;
    float4 color;
};

RWStructuredBuffer<VertexData> vertices;
AppendStructuredBuffer<uint3> indices;

[numthreads(8,8,1)]
void UnprojectKernel (uint3 id : SV_DispatchThreadID)
{
    float d = depthTexture.Load(id.xyz); // TODO should this be id.xy? or just array access [id.xy]?
    
    // TODO can't exclude any Vertices at this stage or else I muck up the indices
    //if(d < MinDistance || d > MaxDistance)
    //    return;

    float3 unprojection = {id.x - PPX, PPY - id.y, 1};
    float4 p = float4(d * unprojection * UnprojectionMultiplier, 1);
    
    // convert the color from YUV to RGB
    float y = colorTextureY[id.xy];
    float u = colorTextureU[uint2(id.x / 2, id.y / 2)]; // TODO can this be id.xy/2?
    float v = colorTextureV[uint2(id.x / 2, id.y / 2)];

    u = u - 0.5;
    v = v - 0.5;
    float r = (1.164f * y + 1.596f * v);
    float g = (1.164f * y - 0.813f * v - 0.391f * u);
    float b = (1.164f * y + 2.018f * u);

    // place this vertex in the VertexBuffer
    VertexData vertex = {p, float4(r, g, b, 1)};
    vertices[id.y * 320 + id.x] = vertex;

    // for every row/col except the last, put indices for two triangles
    // into the Index Buffer below and to the right of the current vertex.
    // TODO later: also check for depth difference between pixels and
    // exclude triangles which exceed a threshold in depth difference
    // But all vertex depths need to be calculated first? Can I chain the
    // stages one after another? Well I could also just sample the depth texture
    // 4 times even when I'm only processing top-left vertex
    // FIXME try to get width and height from groups x threads or something?
    // FIXME or else pass them to the shader in a buffer
    // FIXME might be that 0, 0 is bottom-left, not top-left of depth (all? textures)
    if ((id.x > 0) && (id.y > 0))
    {
        // add the top-left triangle if none of the depths are 0
        uint bottomleft = id.y * 320 + id.x;
        if (depthTexture[id.xy] > 0.1 && depthTexture[uint2(id.x, id.y + 1)] > 0.1 && depthTexture[uint2(id.x + 1, id.y)] > 0.1)
        {
            indices.Append(uint3(bottomleft, bottomleft + 320, bottomleft + 1));           // bottom-left, top-left, bottom-right
        }

        // add the lower-right triangle if none of the depths are 0
        if (depthTexture[uint2(id.x, id.y + 1)] > 0.1 && depthTexture[uint2(id.x + 1, id.y + 1)] > 0.1 && depthTexture[uint2(id.x + 1, id.y)] > 0.1)
        {
            indices.Append(uint3(bottomleft + 320, bottomleft + 320 + 1, bottomleft + 1));          // top-left, top-right, bottom-right
        }
    }
}
